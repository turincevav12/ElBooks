{
	"name": "Прикладное программирование",
	"textBook": [
		{
			"abzac": "Аннотация",
			"textAbzac": "Дисциплина «Прикладное программирование» является составной\nчастью профессионального модуля «Разработка программных модулей\nпрограммного обеспечения для компьютерных систем» и имеет своей\nцелью формирование профессиональных компетенций в области\nосуществления разработки кода программного продукта на основе\nготовой спецификации на уровне модуля.\nДля освоения курса «Прикладное программирование» студент\nдолжен изучить дисциплины: «Основы программирования», «Основы\nтестирования программного обеспечения», «Системное\nпрограммирование» и «Технология разработки программного\nобеспечения».\nОсвоение данной дисциплины необходимо обучающемуся для\nуспешного прохождения производственной практики и выполнения\nвыпускной квалификационной работы.\nУчебное пособие предназначено для студентов 4 курса (на базе 9\nклассов), обучающихся в бизнес-колледже на отделении\n«Программирование в компьютерных системах».\nЛекционная часть – 48 часа;\nЛабораторные занятия – 48 часов;\nСамостоятельная работа – 36 часов.\nВ результате освоения дисциплины обучающийся должен знать:\n− основные этапы разработки программного обеспечения;\n− основные принципы технологии структурного и объектно-\nориентированного программирования;\n− основные принципы отладки и тестирования программных\nпродуктов;\n− методы и средства разработки технической документации.\nВ результате освоения дисциплины обучающийся должен уметь:\n− осуществлять разработку кода программного модуля на\nсовременных языках программирования;\n− создавать программу по разработанному алгоритму как\nотдельный модуль;\n− выполнять отладку и тестирование программы на уровне\nмодуля;\n−\nВ результате освоения дисциплины обучающийся должен иметь\nнавыки:\n− разработки алгоритма поставленной задачи и реализаций его\nсредствами автоматизированного проектирования;\n− разработки кода программного продукта на основе готовой\n7\nспецификации на уровне модуля;\n− использования инструментальных средств на этапе отладки\nпрограммного продукта;\n− проведения тестирования программного модуля по\nопределенному сценарию.\nУчебное пособие разработано старшим преподавателем кафедры «\nПрикладная математика и Информационные технологии» ДГУНХ\nАмиргамзаевым Г.Г. "
		},
		{
			"abzac": "Лекционный материал по дисциплине. ",
			"textAbzac": ""
		},
		{
			"abzac": "Тема 1. Введение. ",
			"textAbzac": "1. Цели использования компьютеров при решении прикладных задач.\n2. Основные этапы разработки программ.\n3. Задачи и особенности прикладного программирования. Основные\nинструменты прикладного программиста.\n4. Выбор языка программирования. "
		},
		{
			"abzac": "",
			"textAbzac": "Прикладное программное обеспечение\nПрикладное программное обеспечение — программа, предназначенная\nдля выполнения определенных пользовательских задач и рассчитанная на\nнепосредственное взаимодействие с пользователем.\nПрограммное обеспечение, предназначенное для использования в\nходе проектирования, разработки и сопровождения программ, в отличие\nот прикладного и системного программного обеспечения. Строго говоря,\nопределение последнего включает в себя определение инструментального,\nпоэтому инструментальное можно считать обособленным подклассом\nприкладного ПО.\nСистемное программное обеспечение\nКомплекс программ, которые обеспечивают управление\nкомпонентами компьютерной системы, такими как процессор,оперативная\nпамять, устройства ввода-вывода, сетевое оборудование, выступая как\n«межслойный интерфейс», с одной стороны которого аппаратура, а с другой —\nприложения пользователя. В отличие\nот прикладногопрограммногообеспечения, системное не решает конкретные\nпрактические задачи, а лишь обеспечивает работу других программ,\nпредоставляя им сервисные функции, абстрагирующие детали аппаратной\nи микропрограммной реализации вычислительной системы, управляет\nаппаратными ресурсами вычислительной системы. Отнесение того или иного\nпрограммного обеспечения к системному условно, и зависит от соглашений,\nиспользуемых в конкретном контексте. Как правило, к системному\n\nпрограммному обеспечению относятся операционные системы\n[⇨]\n, утилиты\n[⇨]\n,\nсистемы программирования\n[⇨]\n, системы управления базами данных\n[⇨]\n, широкий\nкласс связующего программного обеспечения.\nКачество программного обеспечения\nХарактеристика программного обеспечения (ПО) как степени его\nсоответствия требованиям. При этом требования могут трактоваться довольно\nшироко, что порождает целый ряд независимых определений понятия. Чаще\nвсего используется определение ISO 9001, согласно которому качество есть\n«степень соответствия присущих характеристик требованиям».\nТестирование программного обеспечения\nПроцесс исследования программного обеспечения (ПО) с целью\nполучения информации о качестве продукта. С точки зренияISO 9126, качество\nпрограммного обеспечения можно определить как совокупную характеристику\nисследуемого ПО с учётом следующих составляющих:\n• Надёжность\n• Сопровождаемость\n• Практичность\n• Эффективность\n• Мобильность\n• Функциональность\nПрикладное программирование представляет собой использование\nразличных программных средств для создания прикладных программ или\nприложений.\nПрикладная программа или приложение — это программа,\nпредназначенная для выполнения определенных пользовательских задач\nи рассчитанная на непосредственное взаимодействие с пользователем.\nВ большинстве операционных систем \n\nобращаться к ресурсам компьютера напрямую, а взаимодействуют\nс оборудованием и проч. посредством операционной системы.\n1. Цели использования компьютеров при решении прикладных задач.\nРешение задач с использованием компьютера характеризуется\nнесколькими этапами, часть из которых выполняются непосредственно\nчеловеком, остальные - человеком и машиной:\nПостановка задачи. Описание исходных данных, формулирование цели\nзадачи. Построение информационной модели. Описание реального объекта\nисследования в допустимых для реализации задачи терминах, чтобы свести\nисследования реального объекта к решению задачи на модели.\nВыбор программного обеспечения. Определение необходимого прикладного\nпрограммного обеспечения (если оно есть) или разработка нового\nпрограммного обеспечения (разработка алгоритма, выбор системы\nпрограммирования, написание и тестирование программы).\n2. Основные этапы разработки программ.\nРешение любой задачи на ЭВМ представляет собой процесс обработки\nданных с помощью программы. Создание такой программы предполагает\nвыполнение ряда последовательных этапов:\n1. Постановка задачи. На этом этапе подробно описывается исходная\nинформация и формируются требования к результату, а также\nописывается поведение программы в особых случаях.\n2. Мат. или инф, моделирование. Этот этап создает мат. модель\nрешаемой задачи, которая может быть реализована на компьютере.\n3. Разработка или выбор алгоритма.\n4. Программирование. Программой называется последовательность\nдействий, направленных на выполнение их некоторым исполнителем.\n5. Ввод программы и исходных данных в ЭВМ.\n6. Тестирование и отладка программы.\n7. Исполнение программы и анализ результатов\n\nПервый этап представляет собой постановку задачи. На этом этапе\nформулируется цель задачи, определяется взаимосвязь с другими задачами,\nраскрывается состав и форма представления входной, промежуточной и\nрезультативной информации, характеризуются формы и методы контроля\nдостоверности информации на ключевых этапах решения задачи, определяются\nформы взаимодействия пользователя с ЭВМ в ходе решения задачи и т.п.\nНа втором этапе разработки программы выполняется формализованное\nописание программы, т.е. устанавливаются и формулируются средства языка\nматематики логико-математические зависимости между исходными и\nрезультатными данными. Для задач, допускающих возможность\nматематического описания, необходимо выбрать численный метод решения, а\nдля нечисловых задач – принципиальную схему решения в виде однозначно\nпонимаемой последовательности выполнения элементарных математических и\nлогических операций.\nТретий этап подготовки решения задачи на ВМ представляет собой\nалгоритмизацию ее решения, т.е. разработку оригинального или адаптацию\nизвестного алгоритма. Алгоритмизация – это сложный процесс, носящий в\nзначительной степени творческий характер. Постановка задачи и ее\nалгоритмизация составляют до 20-30% общего времени на разработку\nпрограммы. Сложность и ответственность реализации данного этапа\nобъясняется тем, что для решения одной и той же задачи, как правило,\nсуществует множество различных алгоритмов.\nАлгоритм – это точное предписание, определяющее вычислительный\nпроцесс, ведущий от варьируемых начальных данных к искомому результату.\nЭто конечный набор правил, однозначно раскрывающих содержание и\nпоследовательность выполнения операций для систематического решения\nопределенного класса задач за конечное число шагов.\nЧетвертый этап – составление программы. На этом этапе производится\nперевод описания алгоритма на один из доступных для ЭВМ языков описания. \n\nИсторически термин «алгоритм» произошел от фамилии узбекского\nматематика IX века Мухаммада ибн Муса ал-Хорезми, который впервые\nсформулировал правила четырех основных арифметических действий.\nПоначалу именно эти правила назывались алгоритмами, но затем термин\nполучил дальнейшее развитие в первую очередь в математике – алгоритмом\nстал называться любой способ вычислений, единый для некоторого класса\nисходных данных. Например, нахождение производной функции. Одна из\nважнейших задач обучения математике состоит именно в освоении общих\nвычислительных алгоритмов. Другими словами, если школьника учат\nперемножать столбиком два числа, то при этом предполагается, что он\nосваивает не умножение конкретных выбранных чисел, а универсальный\nспособ (алгоритм), который в дальнейшем может быть применен для\nнахождения произведения любой пары конечных чисел.\nАлгоритм – это точно определенная (однозначная) последовательность\nпростых (элементарных) действий, обеспечивающих решение любой задачи из\nнекоторого класса. Однако данное утверждение нельзя принять в качестве\nстрогого определения алгоритма, поскольку в нем использованы другие\nнеопределенные понятия – однозначность, элементарность и пр.\n3. Выбор языка программирования.\nПри выборе языка программирования нужно учитывать множество\nфакторов. Например, если при разработке динамической Web-страницы вы в\nкачестве наилучшего варианта выберите JavaServer Pages (JSP)/сервлеты,\nдругие могут предпочесть PHP или аналогичный язык сценариев. Не\nсуществует какого-то одного языка, который является наилучшим выбором.\nМожно отдать предпочтение определенным факторам, таким как\nпроизводительность и безопасность корпоративных приложений, по сравнению\nс другими факторами, такими как количество строк кода. Любое решение\nсопряжено с какими-то компромиссами. \n\nПосле получения проекта или задания нужно выполнить\nподготовительную работу до решения поставленной задачи. Зачастую выбор\nязыка не рассматривается как часть этой подготовительной работы.\nПри выборе языка для персонального проекта можно положиться на свои\nличные предпочтения. Здесь может оказаться важным количество строк кода;\nочевидным выбором будет язык, позволяющий выполнить задачу при помощи\n10 строк кода вместо 20. Сначала хочется получить решение, а потом\nпозаботиться об удобочитаемости или производительности.\nВ проектах для крупных организаций применяется другой сценарий. Для\nрешения конкретной проблемы группы разработчиков создают компоненты,\nвзаимодействующие и взаимосвязанные между собой. На выбор языка могут\nповлиять такие факторы, как переносимость программы на другую платформу\nили доступность ресурсов.\nПравильный выбор языка программирования поможет создать\nкомпактное, простое в отладке, расширении, документировании и исправлении\nошибок решение. При выборе языка программирования учитываются\nследующие факторы:\n• Целевая платформа.\n• Гибкость языка.\n• Время исполнения проекта.\n• Производительность.\n• Поддержка и сообщество.\nЦелевая платформа\nСамым важным фактором является платформа, на которой программа\nбудет работать. Рассмотрим для примера Java™ и C. Если программа написана\nна C и должна работать на машинах с Windows® и Linux®, потребуются\nкомпиляторы для платформ и два разных исполняемых файла. В случае с Java\nсгенерированного байт-кода будет достаточно для выполнения программы на\nлюбом компьютере, на котором установлена виртуальная Java-машина. \n\nАналогичный аргумент применим и для Web-сайтов. Они должны\nвыглядеть и работать одинаково во всех браузерах. Использование тегов CSS3\nи HTML5 без проверки совместимости с браузерами приведет к разному\nотображению и поведению сайта в разных браузерах.\nГибкость\nГибкость языка определяется тем, насколько легко можно добавлять к\nсуществующей программе новые функциональные возможности. Это может\nбыть добавление нового набора функций или использование существующей\nбиблиотеки для добавления новой функциональности.\nВремя исполнения проекта\nВремя исполнения – это время, необходимое для создания рабочей версии\nпрограммы, т.е. версии, готовой для работы в производственных условиях и\nвыполняющей предусмотренные функции. При расчете этого времени\nнеобходимо учитывать не только логику управления, но и логику\nпредставления.\nВремя исполнения проекта очень зависит от размера кода. Теоретически,\nчем легче изучить язык и чем меньше объем кода, тем меньше это время.\nНапример, сайт управления контентом на PHP-сценариях можно\nразработать за несколько дней, в то время как создание кода сервлетов может\nзанять несколько месяцев, при условии, что вы начали изучать оба языка с\nнуля.\nПроизводительность\nКаждая программа и платформа имеет определенный предел\nпроизводительности, и на эту производительность влияет используемый при\nразработке язык. Существует множество способов сравнения скорости работы в\nодинаковой среде программ, написанных на разных языках. Можно\nиспользовать различные эталонные тесты, хотя их результаты не являются\nконкретной оценкой производительности какого бы то ни было языка. "
		},
		{
			"abzac": "Тема 2. Технологии разработки прикладного программного обеспечения. ",
			"textAbzac": "1.Технологии прикладного программирования: цели, задачи и основные\nпринципы и инструменты.\n2. Алгоритмическая и объектно-ориентированная декомпозиция.\nТехнологией программирования называют совокупность методов и средств,\nиспользуемых в процессе разработки программного обеспечения. Как любая\nдругая технология, технология программирования представляет собой набор\nтехнологических инструкций, включающих:\n• указание последовательности выполнения технологических операций;\n• перечисление условий, при которых выполняется та или иная операция;\n• описания самих операций, где для каждой операции определены\nисходные данные, результаты, а также инструкции, нормативы,\nстандарты, критерии и методы оценки и т. п.\nКроме набора операций и их последовательности, технология также\nопределяет способ описания проектируемой системы, точнее модели,\nиспользуемой на конкретном этапе разработки.\nРазличают технологии, используемые на конкретных этапах разработки\nили для решения отдельных задач этих этапов, и технологии, охватывающие\nнесколько этапов или весь процесс разработки. В основе первых, как правило,\nлежит ограниченно применимый метод, позволяющий решить конкретную\nзадачу. В основе вторых обычно лежит базовый метод или подход (парадигма),\nопределяющий совокупность методов, используемых на разных этапах\nразработки, или методологию.\nИсторически в развитии программирования можно выделить несколько\nпринципиально отличающихся методологий.\nИзначально понятие технологии как таковой — это 60-е годы прошлого\nстолетия — это период \"стихийного\" программирования. В этот период\nотсутствовало понятие структуры программы, типов данных и т.д. Вследствие\nэтого код получался запутанным, противоречивым. Программирование тех лет\nсчиталось искусством. Конец 60-х — кризис в программирование.\nВыход из этого кризиса — переход к структурной парадигме\nпрограммирования. Структурный подход к программированию представляет\nсобой совокупность рекомендуемых технологических приемов, охватывающих\nвыполнение всех этапов разработки программного обеспечения. В основе\nструктурного подхода лежит декомпозиция (разбиение на части) сложных\nсистем с целью последующей реализации в виде отдельных небольших\nподпрограмм. С появлением других принципов декомпозиции (объектного, \n16\nлогического и т.д.) данный способ получил название процедурной\nдекомпозиции.\nДругим базовым принципом структурного программирования является\nиспользование при составлении программ только базовых алгоритмических\nструктур (см. билет 4), запрет на использование оператора GOTO.\nСтруктурный подход требовал представления задачи в виде иерархии\nподзадач простейшей структуры. Проектирование осуществлялось \"сверху-\nвниз\" и подразумевало реализацию общей идеи, обеспечивая проработку\nинтерфейсов подпрограмм. Одновременно вводились ограничения на\nконструкции алгоритмов, рекомендовались формальные модели их описания, а\nтакже специальный метод проектирования алгоритмов — метод пошаговой\nдетализации.\nПоддержка принципов структурного программирования была заложена в\nоснову так называемых процедурных языков программирования. Как правило,\nони включали основные \"структурные\" операторы передачи управления,\nподдерживали вложение подпрограмм, локализацию и ограничение области\n\"видимости\" данных. Среди наиболее известных языков этой группы стоит\nназвать PL/1, ALGOL-68, Pascal, С.\nДальнейший рост сложности и размеров разрабатываемого программного\nобеспечения потребовал развития структурирования данных. Как следствие\nэтого в языках появляется возможность определения пользовательских типов\nданных. Одновременно усилилось стремление разграничить доступ к\nглобальным данным программы, чтобы уменьшить количество ошибок,\nвозникающих при работе с глобальными данными. В результате появилась и\nстала развиваться технология модульного программирования.\n2. Алгоритмическая и объектно-ориентированная декомпозиция.\nДекомпозиция — научный метод, использующий структуру задачи и\nпозволяющий заменить решение одной большой задачи решением серии\nменьших задач, пусть и взаимосвязанных, но более простых.\nДекомпозиция, как процесс расчленения, позволяет рассматривать любую\nисследуемую систему как сложную, состоящую из отдельных взаимосвязанных\nподсистем, которые, в свою очередь, также могут быть расчленены на части. В\nкачестве систем могут выступать не только материальные объекты, но и\nпроцессы, явления и понятия.\nОбъектно-ориентированный подход использует объектную\nдекомпозицию. При этом статическая структура системы описывается в\n17\nтерминах объектов и связей между ними, а поведение системы описывается в\nтерминах обмена сообщениями между объектами. Каждый объект системы\nобладает своим собственным поведением, моделирующим поведение объекта\nреального мира.\nПонятие объект впервые было использовано около 30 лет назад в\nтехнических средствах при попытках отойти от традиционной архитектуры фон\nНеймана и преодолеть барьер между высоким уровнем программных\nабстракций и низким уровнем абстрагирования на уровне компьютеров. С\nобъектно-ориентированной архитектурой также тесно связаны объектно-\nориентированные операционные системы. Однако наиболее значительный\nвклад в объектный подход был внесен объектными и объектно-\nориентированными языками программирования: Simula, Smalltalk, С++, Object\nPascal. На объектный подход оказали влияние также развивавшиеся достаточно\nнезависимо методы моделирования баз данных, в особенности подход\nсущность – связь.\nКонцептуальной основой объектно-ориентированного подхода является\nобъектная модель. Основными ее элементами являются:\n• абстрагирование;\n• инкапсуляция;\n• модульность;\n• иерархия.\nКроме основных, имеются еще три дополнительных элемента, не являющихся в\nотличие от основных строго обязательными:\n• типизация;\n• параллелизм;\n• устойчивость.\nАбстрагирование – это выделение существенных характеристик\nнекоторого объекта, которые отличают его от всех других видов объектов и,\nтаким образом, четко определяют его концептуальные границы относительно\nдальнейшего рассмотрения и анализа. Абстрагирование концентрирует\n18\nвнимание на внешних особенностях объекта и позволяет отделить самые\nсущественные особенности его поведения от деталей их реализации. Выбор\nправильного набора абстракций для заданной предметной области представляет\nсобой главную задачу объектно-ориентированного проектирования.\nИнкапсуляция – это процесс отделения друг от друга отдельных\nэлементов объекта, определяющих его устройство и поведение. Инкапсуляция\nслужит для того, чтобы изолировать интерфейс объекта, отражающий его\nвнешнее поведение, от внутренней реализации объекта. Объектный подход\nпредполагает, что собственные ресурсы, которыми могут манипулировать\nтолько методы самого класса, скрыты от внешней среды. Абстрагирование и\nинкапсуляция являются взаимодополняющими операциями: абстрагирование\nфокусирует внимание на внешних особенностях объекта, а инкапсуляция (или,\nиначе, ограничение доступа) не позволяет объектам пользователям различать\nвнутреннее устройство объекта"
		},
		{
			"abzac": "Тема 3. Принципы объектно-ориентированного анализа",
			"textAbzac": "1. Принципы ООП. Абстрагирование, инкапсуляция, наследование,\nполиморфизм, модульность, сохраняемость, параллелизм.\n2. Объекты и типы объектов.\n3. Атрибуты и типы атрибутов. Экземпляры и состояния. Жизненный\nцикл и поведение объектов.\n1. Принципы ООП. Абстрагирование, инкапсуляция, наследование,\nполиморфизм, модульность, сохраняемость, параллелизм.\nОбъектно-ориентированная технология основывается на так\nназываемой объектной модели. Основными ее принципами являются:\nабстрагирование, инкапсуляция, модульность, иерархичность, типизация,\nпараллелизм и сохраняемость. Каждый из этих принципов сам по себе не нов,\nно в объектной модели они впервые применены в совокупности.\nОбъектно-ориентированный анализ и проектирование принципиально\nотличаются от традиционных подходов структурного проектирования: здесь\nнужно по-другому представлять себе процесс декомпозиции, а архитектура\nполучающегося программного продукта в значительной степени выходит за\nрамки представлений, традиционных для структурного программирования.\nОтличия обусловлены тем, что структурное проектирование основано на\nструктурном программировании, тогда как в основе объектно-\nориентированного проектирования лежит методология объектно-\nориентированного программирования, К сожалению, для разных людей термин\n\"объектно-ориентированное программирование\" означает разное. В этой главе\nмы выясним, чем является и чем не является объектно-ориентированная\nразработка программ, и в чем отличия этого подхода к проектированию от\nдругих с учетом семи перечисленных выше элементов объектной модели.\nОбъектно-ориентированное программирование. Объектно-\nориентированное программирование - это методология программирования,\nоснованная на представлении программы в виде совокупности объектов,\nкаждый из которых является экземпляром определенного класса, а классы\nобразуют иерархию наследования.\n20\nАбстракция (абстрагирование) — это способ выделить набор значимых\nхарактеристик объекта, исключая из рассмотрения незначимые.\nСоответственно, абстракция — это набор всех таких характеристик.\nИнкапсуляция — это свойство системы, позволяющее объединить\nданные и методы, работающие с ними в классе, и скрыть детали реализации от\nпользователя.\nНаследование — это свойство системы, позволяющее описать новый\nкласс на основе уже существующего с частично или полностью\nзаимствующейся функциональностью. Класс, от которого производится\nнаследование, называется базовым, родительским или суперклассом. Новый\nкласс — потомком, наследником или производным классом.\nПолиморфизм — это свойство системы использовать объекты с\nодинаковым интерфейсом без информации о типе и внутренней структуре\nобъекта.\nПАРАЛЛЕЛИЗМ - это возможность иметь несколько объектов, которые\nвыполняются одновременно.\nМодульность в языках программирования — принцип, согласно\nкоторому программное средство (ПС, программа, библиотека, веб-приложение\nи др.) разделяется на отдельные именованные сущности,\nназываемые модулями. Модульность часто является средством упрощения\nзадачи проектирования ПС и распределения процесса разработки ПС между\nгруппами разработчиков. При разбиении ПС на модули для каждого модуля\nуказывается реализуемая им функциональность, а также связи с другими\nмодулями.\nСохраняемость - способность данных существовать в определенном\nвремени.\n2. Объекты и типы объектов.\nОбъект в программировании — некоторая сущность в виртуальном\nпространстве, обладающая определённым состоянием и поведением, имеющая\n21\nзаданные значения свойств (атрибутов) и операций над ними (методов). Как\nправило, при рассмотрении объектов выделяется то, что объекты принадлежат\nодному или нескольким классам, которые определяют поведение (являются\nмоделью) объекта. Термины «экземпляр класса» и «объект»\nвзаимозаменяемы.\nОбъект, наряду с понятием класс, является важным понятием объектно-\nориентированногоподхода.\nОбъектыобладаютсвойствами наследования, инкапсуляции и полиморфизма.\nТермин объект в программном обеспечении впервые был введен в\nязыке Simula и применялся для моделирования реальности.\nТип объекта – это принадлежность его к определенной группе в\nзависимости от характеристик.\n3. Атрибуты и типы атрибутов. Экземпляры. Жизненный цикл и\nповедение объектов.\n• Атрибут — в некоторых файловых системах одно из свойств файла.\n• Атрибут — иное название для полякласса в объектно-ориентированном\nпрограммировании.\nТипы атрибутов определяют, какие значения могут принимать\nатрибуты.Существуют следующие типы атрибутов:\n1) Целочисленный – Значением атрибута может являться любое целое число\n2) Дробный –Значением атрибута может являться любое дробное число\n3) Дата –Значением атрибута может являться дата в формате ДД. ММ. ГГГГ\n4) Перечисление – значения атрибута задаются в виде последовательности\nстроковых и числовых значений при создании и редактировании атрибута.\nЗначения задаются отдельно для каждого языка. При создании и\nредактировании товара можно выбрать одно из них из выпадающего списка в\nкачестве значения атрибута типа «Перечисление» для данного товара.\n5) Строковый – атрибут данного типа может принимать строку в качестве\nзначения. Значения задаются отдельно для каждого языка при создании и\nредактировании товара.\n6) Файл –Значением атрибута может являться URL файла\n22\n7) Языково-нечувствительная строка – атрибут данного типа может принимать\nстроку в качестве значения. Значение задается одно для всех языков при\nсоздании и редактировании товара.\n8) Булев - Значением атрибута может являться значение «Да» или «Нет»\n9) Языково-нечувствительное перечисление - значения атрибута задаются в\nвиде последовательности строковых и числовых значений при создании и\nредактировании атрибута. Значения задаются одновременно для всех языков.\nПри создании и редактировании товара можно выбрать одно из них из\nвыпадающего списка в качестве значения атрибута типа «Перечисление» для\nданного товара.\n10) Файл-картинка – атрибут данного типа может принимать URL файла с\nизображением, который задается с помощью диалогового окна или вводится\nвручную при добавлении или редактировании товара.\nЭкземпляры\nВ объектно-ориентированной программе с применением классов каждый\nобъект является «экземпляром» некоторого конкретного класса, и других\nобъектов не предусмотрено. То есть «экземпляр класса» в данном случае\nозначает не «пример некоторого класса» или «отдельно взятый класс», а\n«объект, типом которого является какой-то класс». При этом в разных языках\nпрограммирования допускается либо не допускается существование еще каких-\nто типов данных, экземпляры которых не являются объектами (то есть язык\nопределяет, являются ли объектами такие вещи, как числа, массивы и\nуказатели, или не являются, и, соответственно, есть ли такие классы как\n«число», «массив» или «указатель», экземплярами которых были бы каждое\nконкретное число, массив или указатель).\nНапример, абстрактный тип данных «строка текста» может быть\nоформлен в виде класса, и тогда все строки текста в программе будут являться\nобъектами — экземплярами класса «строка текста».\nЖизненный цикл объекта\nС точки зрения программы объектрождается тогда, когда под него\nвыделяетсяпамять и происходит инициализация егосостояния. \n23\nОбъект заканчивает свой жизненный путьтогда, когда высвобождаются\nзанятые имресурсы, и память возвращается в системудля дальнейшего\nиспользования.\nВ разных объектно-ориентированных языкахсуществуют разные\nмеханизмы, управляющиерождением и уничтожением объектов.\nПримером для C++ могут служить конструкторы идеструкторы,\nоператоры new и delete.\nВ Java существуют только конструкторы иоператор new. Нет механизма\nраспределения ивыбора памяти под объекты. За освобождение памятиотвечает\nспециальная программа сборщик мусора\nПоведение\nОбъекты не существуют изолированно, авзаимодействуют друг с другом,\nреализуяповедение.Рассмотрим известную аллегорию просамолет: ’’Самолет\nпредставляет собой совокупностьвещей, каждая из которых по\nотдельностистремится упасть на землю, но вместе, вовзаимодействии, они\nпреодолевают этутенденцию’’.\nПоведение – это то, как объектдействует и реагирует;\nповедениевыражается в терминах состояния объектаи передачи\nсообщений.Поведение объекта – это его наблюдаемая и проверяемая извне\nдеятельность.Взаимодействие объектов описывается втерминах передачи и\nобработкисообщений.Поведение объекта определяетсяпереданными ему\nсообщениями и еготекущим состоянием. Причем, некоторыесообщения могут\nизменить внутреннеесостояние объекта.Состояние объекта\nпредставляетсуммарный результат его поведения. "
		},
		{
			"abzac": "Тема 4. Объектно-ориентированное проектирование. ",
			"textAbzac": "1. Документирование результатов анализа и проектирования.\n2. Основные понятия UML (UnifiedModelingLanguage).Сущности и\nотношения.\n1. Документирование результатов анализа и проектирования.\nОбъектно-ориентированное проектирование(ООП) -\nэточасть объектно-ориентированной методологии, которая предоставляет\nвозможность программистам оперировать понятием «объект», нежели\nпонятием «процедура» при разработке своего кода. Объекты\nсодержат инкапсулированные данные и процедуры, сгруппированные вместе,\nотображая т.о. сущность объекта. «Интерфейс объекта», описывает\nвзаимодействие с объектом, то, как он определен. Программа, полученная при\nреализации объектно-ориентированного исходного кода, описывает\nвзаимодействие этих объектов.\n2. ОсновныепонятияUML (UnifiedModelingLanguage).Сущности и\nотношения.\nУнифицированный язык моделирования (UML, Unified Modeling\nLanguage) является преемником методов объектно-ориентированного анализа и\nпроектирования (OOA&D), которые появились в конце 80-х и начале 90-х\nгодов.\nПервое упоминание об унифицированном методе (Unified Method) версии\n0.8 появилось в 1995 году на конференции OOPSLA ’95. Данный метод был\nпредложен Гради Бучом и Джимом Рамбо. В дальнейшем к ним присоединился\nАйвар Якобсон и в течение 1996 года Г. Буч, Д. Рамбо, А. Якобсон, получившие\nширокую известность как «трое друзей» (amigos) продолжали работа над своим\nметодом, который к тому времени получил название унифицированный язык\nмоделирования (UML). Однако помимо данного метода сообществом\nразработчиком были предложены и другие методы. Для стандартизации этих\nметодов в рамках OMG (Object Management Group) была сформирована\nинициативная группа. \n25\nВ результате работы группы появилась версия языка UML 1.1. Текущей\nверсией языка UML является версия 1.5.Ведется работа над спецификацией\nязыка UML версии 2.0.\nUML – это название языка моделирования, но не метода. Следует\nразличать эти понятия. Большинство методов включают в себя помимо языка\nмоделирования процесс. Язык моделирования – это нотация (главным образом\nграфическая), которая используется разработчиками для описания проекта.\nПроцесс – это рекомендация относительно этапов, которых необходимо\nпридерживаться при выполнении проекта.\nUML — прежде всего язык, и, как всякое языковое средство, он предоставляет\nсловарь и правила комбинирования слов в этом словаре. В данном случае\nсловарь и правила фокусируются на концептуальном и физическом\nпредставлениях системы. Язык диктует, как создать и прочитать модель,\nоднако не содержит никаких рекомендаций о том, какую модель системы\nнеобходимо создать, — это выходит за рамки UML и является прерогативой\nпроцесса разработки программного обеспечения. В связи с этим, видимо, UML\nдовольно часто ассоциируют с RUP — одним из возможных процессов,\nрекомендующих, какие модели, как и когда нужно создавать для успешной\nразработки продукта.\nUML — это язык визуализации. Написание моделей на UML преследует\nодну простую цель — облегчение процесса передачи информации о системе. За\nкаждым символом UML стоит строго определенная семантика, что позволяет\nизбегать ошибок интерпретации (ответы на вопросы типа «а что имел в виду\nразработчик Х, когда он описал иерархию классов Y…» и т.п. будут достаточно\nпрозрачны).\nUML — это язык спецификаций и точных определений. В этом смысле\nмоделирование на UML означает построение моделей, которые точны,\nнедвусмысленны и полны. \n26\nUML — это язык конструирования. UML не является визуальным языком\nпрограммирования, но модели в терминах UML могут быть отображены на\nопределенный набор объектно-ориентированных языков программирования.\nUML предоставляет возможности прямого (существующая модель ®\nновый код) и обратного (существующий код ® новая модель) проектирования.\nДостаточно часто средства UML-моделирования реализуют отображения UML-\nмоделей в коде на языках Java, C++, CORBA, VB, Smalltalk.\nUML — это язык документирования. Процесс разработки программного\nобеспечения предусматривает не только написание кода, но и создание таких\nартефактов, как список требований, описание архитектуры, дизайн, исходный\nкод системы, планирование проекта, тесты, набор прототипов, релизы\nпродукта. В зависимости от культуры разработки продукта в той или иной\nкомпании степень формализации данных документов существенно различается,\nварьируясь от строго определенных шаблонов и формата документов до\nразговоров на произвольную тему по e-mail или лично. Тем не менее все эти\nартефакты критичны для успешного процесса разработки продукта. UML\nпредоставляет средства отображения требований к системе, построения\nдокументации, тестов, моделирования необходимых действий для\nпланирования проекта и для управления поставленными конечному\nпользователю релизами.\nОсновными элементами UML являются сущности (Thing), отношения\n(Relationship), диаграммы (Diagram). Сущности являются ключевыми\nабстракциями языка, отношения связывают сущности вместе, диаграммы\nгруппируют коллекции сущностей, которые представляют интерес.\nСущности\nСтруктурные сущности являются существительными языка. К ним относятся:\n• классы (Class) — это набор объектов, разделяющих одни и те же атрибуты,\nоперации, отношения и семантику. Класс реализует один или несколько\nинтерфейсов и изображается виде прямоугольника, включающего имя класса,\nимена атрибутов, операций, примечание; \n27\n• интерфейсы (Interface) — это набор операций, которые определяют сервис\nкласса или компоненты. Интерфейс графически изображается в виде круга и,\nкак правило, присоединяется к классу или к компоненту, который реализует\nданный интерфейс;\n• кооперации (Collaboration) — определяют взаимодействие и служат для\nобъединения ролей и других элементов, которые взаимодействуют вместе так,\nчто получающееся в результате поведение объекта оказывается большим, чем\nпросто сумма всех элементов. Изображается в виде эллипса с пунктирной\nграницей;\n• прецеденты (Use case) — описание набора последовательностей действий,\nкоторые выполняются системой и имеют значение для конкретного\nдействующего лица (Actor). Прецеденты изображаются в виде эллипса и\nиспользуются для структурирования поведенческих сущностей в модели;\n• активные классы (Active class) — это классы, чьими экземплярами являются\nактивные объекты, которые владеют процессом или потоком управления и\nмогут инициировать управляющее воздействие. Стереотипами конкретного\nкласса являются процесс (Process) и поток (Thread). Графически такой класс\nизображается как класс с жирной границей;\n• компоненты (Component) — это физически заменяемые части системы,\nобеспечивающие реализацию ряда интерфейсов. Компонент — это физическое\nпредставление таких логических элементов, как классы, интерфейсы и\nкооперации. Предметная область компонентов относится к реализации.\nИзображаются компоненты в виде прямоугольника с ярлыками слева и, как\nправило, имеют только имя и примечание;\n• узлы (Node) — физические объекты, которые существуют во время\nисполнения программы и представляют собой коммуникационный ресурс,\nобладающий, по крайней мере, памятью, а зачастую и процессором. На узлах\nмогут находиться выполняемые объекты и компоненты. Изображаются узлы в\nвиде куба, имеют имя и примечание. \n28\nДанные перечисленных семи типов объектов являются базовыми\nструктурными объектами UML. Существуют также вариации данных объектов,\nтакие как действующие лица (Actor), сигналы (Signal), утилиты (Utility — вид\nкласса), процессы и нити (Process и Thread — виды активного класса),\nприложения (Application), документы (document), файлы (File), библиотеки\n(Library), страницы (Page), таблицы (Table).\nПоведенческие сущности — это динамические части моделей UML. К ним\nотносятся:\n• взаимодействия (Interaction) — включают набор сообщений, которыми\nобмениваются указанные объекты с целью достижения указанной цели.\nВзаимодействие описывается в контексте кооперации и изображается\nнаправленной линией, маркируется именем операции сверху;\n• автоматы (State machine) — спецификации поведения, представляющие собой\nпоследовательности состояний, через которые проходит в течение своей жизни\nобъект, или взаимодействие в ответ на происходящие события (а также\nответные действия объекта на эти события). Автомат прикреплен к исходному\nэлементу (классу, кооперации или методу) и служит для определения\nповедения его экземпляров. Изображается автомат как прямоугольник с\nзакругленными углами.\nГруппирующие сущности — это организационные составляющие\nмоделей UML. К ним относятся пакеты (Package) — обобщенный механизм для\nорганизации элементов в группы. Структурные, поведенческие, группирующие\nсущности могут быть помещены в пакет. Пакеты являются чисто\nконцептуальными сущностями — в отличие от компонентов, существующих во\nвремя исполнения программы. Изображается пакет как папка с ярлыком сверху\nи, как правило, имеет только имя.\nАннотационные сущности — это пояснительные составляющие\nмоделей UML, к которым относятся примечания (Note) — пояснительные\nэлементы языка. Они содержат текст комментария, изображаются в виде\nпрямоугольника с загнутым уголком страницы. \n29\nОтношения.\nК базовым отношениям между объектами, которые позволяют строить блоки\nUML, можно отнести следующие:\n• зависимость (Dependency) — это семантическое отношение между двумя\nсущностями, при котором изменение одной из них (независимой сущности)\nможет отразиться на семантике другой (зависимой). Виды зависимостей,\nкоторые соответствуют нескольким видам отношений между объектами,\nперечислены ниже:\n- абстракция (Abstraction) — представляет собой изменение уровня\nабстрактности для некоторого понятия. Как правило, один из элементов, более\nабстрактный, а второй — более конкретный, хотя возможны ситуации, когда\nоба элемента являются двумя возможными вариантами понятия,\nсуществующими на одном уровне абстракции. К зависимости абстракции\nотносятся следующие стереотипы (в порядке возрастания специфичности\nотношений): трассировать (Trace), уточнять (Refine), реализовать (есть\nсобственная нотация) и выводить (Derive),\n- связывание (Binding) — связывает элемент с шаблоном. Аргументы,\nнеобходимые для параметров шаблона, прикреплены к зависимости связывания\nв виде списка,\n- комбинирование (Combination) — соотносит две части описания\nклассификатора (любой элемент модели, описывающий определенные черты\nструктуры и поведения системы), чтобы получить полное описание элемента,\n- разрешение (Permission) — зависимость (всегда изображается в виде особого\nстереотипа), связывающая тот или иной пакет (или класс) с другим пакетом\n(или классом), которому он предоставляет разрешение использовать свое\nсодержимое. Стереотипами зависимости разрешения являются: быть\nдоступным (Access), быть дружественным (Friend) и импортировать (Import),\n- использование (Usage) — описывает ситуацию, когда одному элементу для\nправильной реализации или функционирования требуется присутствие другого\nэлемента. К стереотипам этого вида зависимости относятся: вызывать (Call), \n30\nсоздать экземпляр (Instantiate), параметр (Parameter) и отправить(Send);\n• ассоциация (Association) — структурное отношение, описывающее множество\nсвязей между объектами классификаторов, где связь (Link) — это соединение\nмежду объектами, которое описывает связи между их экземплярами.\nАссоциации являются как бы клеем, который связывает систему воедино. Без\nассоциаций мы имели бы просто некоторое количество классов, не способных\nвзаимодействовать друг с другом. У ассоциации может быть имя, однако\nосновную информацию об ассоциации следует искать у ее полюсов, где\nописывается, каким образом каждый объект участвует в ассоциации: у\nассоциации есть список, состоящий из двух или более полюсов ассоциации:\nкаждый из них определяет роль, которую играет данный классификатор в этой\nассоциации. Один и тот же классификатор может играть несколько ролей,\nкоторые не являются взаимозаменяемыми. Каждый полюс ассоциации\nописывает свойства, применимые к конкретному объекту этой ассоциации,\nнапример сколько раз один объект может появляться в связях\n(множественность). Некоторые свойства (такие как допустимость навигации)\nприменимы только к бинарным ассоциациям, хотя большинство свойств\nотносится и к бинарным, и к n-арным ассоциациям;\n• обобщение (Generalization) — это отношение специализации/обобщения, при\nкотором объекты специализированного элемента (потомка — Child) можно\nподставить вместо объектов обобщенного элемента (родителя, предка —\nParent). В случае обобщения классов прямой предок может именоваться\nсуперклассом, а прямой потомок — подклассом;\n• реализация (Realization) — отношение между спецификацией и ее\nпрограммной реализацией; указание на то, что поведение наследуется без\nструктуры. \n"
			 
		},
		{
			"abzac": "Тема 5. Основы прикладного программирования с использованием языка С++. ",
			"textAbzac": "1. Структура программы на языке C++.\n2. Понятие проекта.\n3. Компиляция программы и сборка исполняемого модуля.\n1. Структура программы на языке C++.\nПоскольку С++ является надмножеством С, то большинство программ на\nязыке С являются также программами и на языке С++. (Имеется несколько\nнебольших различий между С и С++, благодаря которым некоторые типы\nпрограмм на языке С не будут компилироваться компилятором языка С++.\nМожно писать программы на С++, которые выглядят в точности как программы\nна языке С, но в таком случае не будут использоваться преимущества,\nпредоставляемые С++-программистам. Кроме того, большинство\nпрограммистов, пишущих на языке С++, используют стиль и некоторые\nособенности написания программ, которые присущи только С++. Поскольку\nважно использовать весь потенциал С++, то в этом разделе мы обсудим\nнекоторые из таких особенностей, прежде чем перейти к собственно С++.\nНачнем с примера. Рассмотрим программу на языке С++:\n#include <iostream.h>\n#include <stdio.h>\nint main()\n{\nint i ;\nchar str [80] ;\ncout << \"I like Borland C++.\\n\"; // однострочный комментарий\n/* также можно использовать С-комментарии */\nprintf (\"You can use printf(), but, most С++ programs don' t. \\n\");\n// ввод числа с помощью >>\ncout << \"Enter a number: \";\ncin >> i;\n// выводчисласпомощью<<\ncout << \"Your number is \" << i << \"\\n\"; \n32\n// чтениестроки\ncout << \"Enter a string: \";\ncin >>str;\n// вывод\ncout << str;\nreturn 0;\n}\nКак можно видеть, эта программа выглядит совершенно отлично от обычной\nпрограммы на языке С. Заголовочный файл iostream.h определен С++ и\nпредназначен для поддержки операций ввода/вывода. Включение\nзаголовочного файла stdio.h обусловлено использованием функции printf().\nЕсли используются операции ввода/вывода собственно языка С++, то\nнеобходимости в этом файле нет.\nОдной из особенностей, на которую стоит обратить внимание, служит\nобъявление функции main()\nint main()\nвместо\nint main(void)\nкоторое используют программы на языке С. Причина этого заключается в том,\nчто в языке С++ пустой список параметров эквивалентен спецификатору void.\nЭто означает, что оба типа объявления функции равноправны в рамках языка\nС++. В С++ использование зарезервированного слова void для обозначения\nпустого списка параметров является допустимым, но рассматривается как\nизлишество. Поскольку оно не является необходимым, далее в наших\nпрограммах мы не будем использовать слово void для обозначения пустого\nсписка параметров.\nСледующая строка кода содержит несколько особенностей языка С++:\ncout<< \"I like Borland C++.\\n\"; // однострочный комментарий\nОператор\ncout << \"I like Borland C++.\\n\";\nвыводит на экран «I like Borland С++.», после чего следует переход на\nследующую строку и возврат каретки. В С++ роль оператора << значительно\nрасширена. Он продолжает выполнять роль оператора побитового сдвига влево,\nно используется также как оператор вывода данных в случае, если записан в\nуказанной в примере форме. Слово cout представляет собой идентификатор,\nсоответствующий экрану. Так же как и С, язык С++ поддерживает\nперенаправление ввода/ вывода, но, чтобы избежать дискуссий на эту тему, мы\nможем принять, что cout ссылается на экран. Можно использовать cout и\n33\nоператор << для вывода данных любого встроенного типа, а также для вывода\nстрок символов.\nВажно отметить, что можно продолжать пользоваться функцией printf() (что\nпроиллюстрировано в записанной выше программе) или любой другой\nфункцией ввода/вывода языка С, но большинство программистов находят, что\nиспользование cout<< более соответствуют духу С++. В общем случае\nпрограммы на языке С++ могут использовать любые функции,\nподдерживаемые Borland С++, включая и те, что определены языком С. Однако,\nв тех случаях, когда С++ предлагает альтернативный подход, ему следует\nотдавать предпочтение перед использованием функций языка С, хотя и нет\nправил, предписывающих это.\nВ предыдущей строке кода комментарии С++ следовали за выражением для\nвывода данных. В С++ комментарии определяются двумя способами.\nКомментарии языка С сохраняют свое значе\nние и в С++. Однако в С++ можно также определить комментарии размером в\nодну строку, используя //. Когда комментарии начинаются с //, все, что следует\nза этими знаками, игнорируется компилятором до конца строки. Обычно при\nвключении многострочных комментариев используют нотацию С, а\nоднострочных — С++.\nДалее программа выводит запрос-подсказку пользователю, чтобы он ввел\nчисло. Число читается с клавиатуры, используя следующую инструкцию:\ncin>> i;\nВ С++ оператор >> сохраняет свое значение сдвига вправо, но если он\nиспользуется как показано выше, то служит оператором ввода числа с\nклавиатуры и записи его в переменную i. Идентификатор cin ссылается на\nклавиатуру. В общем случае можно использовать cin >> для загрузки\nпеременных любого базового типа или строки.\nХотя в программе это и не проиллюстрировано, можно свободно\nиспользовать любую функцию С для ввода данных, например, функцию scanf(),\nвместо cin >>. Однако, как и в случае с cout, подавляющее большинство\nпрограммистов находят использование cin >> в большей мере со-\nответствующим духу С++.\nРассмотрим другую интересную строку программы:\ncout<< \"Your number is \" << i << \"\\n\";\nЭтот код выводит на экран следующую фразу (предполагается, что значением i\nслужит 100):\nYour number is 100\nпосле которой идет перевод каретки и переход на новую строку. В общем\nслучае можно выполнять столько операций вывода <<, сколько надо. \n34\nОстальная часть программы демонстрирует, как можно прочитать и вывести\nстроку, используя cin >> и cout <<. При вводе строки cin >> прекращает чтение,\nкак только встречает специальный символ. Это аналогично тому, что делает\nстандартная функция scanf() при вводе строки.\n2. Понятие проекта.\nПроект программы это набор компонентов и установленные отношения\nмежду ними. Структура проекта может включать как интерфейсные, так и\nспециальные компоненты. При этом иметься возможность импорта набора\nкомпонентов оформленных ранее как часть проекта.\nСледует помнить, что основное отличие интерфейсных и специальных\nкомпонентов заключается в назначении, для организации взаимодействия\nпрограммы с человеком используются интерфейсные компоненты,\nоформленные в рамках базового объекта – окно. Количество окон в проекте не\nограничено. Специальные компоненты позволяют организовать работу по\nобработке данных, расчетам и т.п., при этом некоторые специальные\nкомпоненты могут предоставлять собственные диалоговые окна\nвзаимодействия с человеком или работать как расширение интерфейсных\nобъектов.\n3. Компиляция программы и сборка исполняемого модуля.\nКомпилятор – это главный инструмент разработчика C++. Наиболее\nизвестные представители:Visual C++ для платформы Windows и GNU C++\nCompiler для всех остальных платформ. Но существуют и другие, также\nзаслуживающие внимания. При написании программ предпочтительно\nкомпилировать их разными компиляторами. Таким образом обеспечивается\nлучшая проверка и обеспечивается независимость от конкретного компилятора.\nЗадача компилятора – трансляция исходного кода программы в бинарное\nпредставление. Бинарным представлением может быть промежуточный байт-\nкод или машинный код. Компиляция состоит из трех этапов: \n35\n• Работа препроцессора. Это обработка\nдиректив #include, #define, #ifdef и т.д. Препроцессор создает\nфайл с исходным кодом, который включает все файлы, подключаемые\nдирективами #include, вырезая текст, исключенный\nдирективами#ifdef/#ifndef.\n• Синтаксический разбор и трансляция текстового представление в\nбинарное. Обычно на данном этапе получают упрощенный бинарный код,\nпонятный только используемому компилятору.\n• Оптимизация бинарного представление и получение результата в виде\nбинарного файла.\nНа последнем этапе компилирования не обязательно выполняется\nоптимизация, это зависит от флагов компилятора. Оптимизация не\nиспользуется при сборке версии приложения, предназначенного для\nотладки.Следующий этап выполняет не компилятор, а линковщик. Это сборка\nобъектных файлов для получения исполняемого модуля или библиотеки.\nОнлайн компиляторы\nИногда возникает необходимость проверить какую-либо конструкцию на\nдругом компиляторе. Ставить сторонний компилятор только ради этого, вряд-\nли имеет смысл. Можно воспользоваться online компилятором.\n• http://codepad.org/\n• http://ideone.com/\n• http://liveworkspace.org/\n"
		},
		{
			"abzac": "Тема 6. Составные типы данных. ",
			"textAbzac": "1. Массивы, описание доступ к элементам.\nВ языке C/C++, кроме базовых типов, разрешено вводить и использовать\nпроизводные типы, полученные на основе базовых. Стандарт языка\nопределяет три способа получения производных типов:\n1. массив элементов заданного типа;\n2. указатель на объект заданного типа;\n3. функция, возвращающая значение заданного типа.\nМассив – это упорядоченная последовательность переменных одного\nтипа. Каждому элементу массива отводится одна ячейка памяти. Элементы\nодного массива занимают последовательно расположенные ячейки памяти. Все\nэлементы имеют одно имя – имя массива и отличаются индексами –\nпорядковыми номерами в массиве. Количество элементов в массиве называется\nего размером. Чтобы отвести в памяти нужное количество ячеек для\nразмещения массива, надо заранее знать его размер. Резервирование памяти для\nмассива выполняется на этапе компиляции программы.\nОпределение массива в C/C++\nint a[100];//массив из 100 элементов целого типа\nОперация sizeof(a) даст результат 400, т.е.100 элементов по 4 байта.\nЭлементы массива всегда нумеруются с 0:\n0 1 2 ….. 99\n1. Чтобы обратиться к элементу массива, надо указать имя массива и номер элемента в\nмассиве (индекс):\na[0] – индекс задается как константа,\na[55] – индекс задается как константа,\na[I] – индекс задается как переменная,\na[2*I] – индекс задается как выражение.\nЭлементы массива можно задавать при его определении: \n37\nint a[12]={1,2,3,4,5,6,7,8,9,10} ;\nОперация sizeof(a) даст результат 40, т.е.10 элементов по 4 байта.\nint a[12]={1,2,3,4,5};\nОперация sizeof(a) даст результат 40, т.е. 10 элементов по 4 байта. Если\nколичество начальных значений меньше, чем объявленная длина массива,\nто начальные элементы массива получат только первые элементы:\nint a[]={1,2,3,4,5};\nОперация sizeof(a) даст результат 20, т.е. 5 элементов по 4 байта. Длин\nмассива вычисляется компилятором по количеству значений,\nперечисленных при инициализации.\n2. Одномерные и многомерные массивы\nПри работе с массивами очень часто требуется одинаково обработать все\nэлементы или часть элементов массива. Для этого организуется перебор\nмассива.\n^ Перебор элементов массива характеризуется:\n1) направлением перебора;\n2) количеством одновременно обрабатываемых элементов;\n3) характером изменения индексов.\n^ По направлению перебора массивы обрабатывают:\n1) слева направо (от начала массива к его концу);\n2) справа налево (от конца массива к началу);\n3) от обоих концов к середине.\nИндексы могут меняться:\n1) линейно (с постоянным шагом);\n2) нелинейно (с переменным шагом).\n3. Структуры\nСтруктуры в C++ представляют из себя нечто одно целое, что содержит в\nсебе целый набор разнообразных, определенных пользователем данных. \n38\nСтруктуры – это составной тип данных, построенный с использованием\nразнообразных типов. Можно как угодно пытаться дать определение, но вряд\nли любое из определений четко покажет и поможет разобраться начинающему.\n—> Структуры очень похожи на массивы.\n—>Если массивы по определению могут содержать внутри себя множество\nоднотипных элементов, то внутри структур можно описать разное количество\nразнотипных элементов. А сами по себе структуры являются пользовательским\nтипом данных.\nPHP\nint A[10]; // Десять элементов\nstruct MyStruct\n{\nint A;\nchar C[10];\n//При этом каждый из этих десяти элементов состоит\nиз двух элементов определенных внутри структуры\nВнутри описанной структуры определено две\nпеременные разных типов (int и char). Переменных\nвнутри структуры может быть разное количество и\nкаждому элементу может соответствовать нужный тип.\nВажно - В структуре весь интерес не в названии\nструктуры, а в названии объекта, т.е. после описания\nструктуры обязательно создается минимум одна\nпеременная тип которой есть имя структуры.\nВ приведенном примере такая переменная – obj1.\nТакие переменные называются объектами. Вот и\nвыходит, что obj1есть переменная типа MyStruct. При\nэтом в приведенном коде переменная obj1 объявлена\nкак массив переменных из десяти элементов. Каждый\nиз этих десяти элементов имеет тип MyStruct и значит\nкаждый элемент массива состоит из тех элементов,\nкоторые описаны внутри структуры.\nВозможно кому-то это поможет, а кто-то сочтет за\nзапутанное и многословное пустословие.\n//Массив из десяти структур. Или просто массив\nструктур.Так как внутри структуры описано две переменные, то будет\nиспользовано по два значения для каждого из элементов массива структур\n(сейчас увидите)\n Рассматривая приведены й код и вникая в смысл структур нужно понять, что\nтеперь при изменении элементов или для вытаскивания элементов из структуры\nдля каждого отдельного элемента массива нужно обращаться к каждому из\nэлементов самой структуры.\nMyStruct obj1[10]; \n39\nPHP\n#include <string.h>\n#include <iostream.h>\nstruct MyStruct\n{\nMyStruct obj1[10]; //Десятьэлементовтипа MyStruct\n//При этом каждый из этих десяти элементов состоит из\nдвух элементов определенных внутри структуры void\nmain()\n{obj1[0].A=100; //Первый элемент массива переменная\nint A\nstrcpy(ob1[0].C,\"12345\"); //Первый элемент массива\nпеременная char C[10]\n}\n В этом коде в переменные массива присваиваются значения. Обращение к\nэлементам структуры можно прописывать через точку. Чтобы работать с\nэлементами массива, который является массивом структур, нужно транзитом\nчерез массив структур обращаться к тем переменным, которые описаны внутри\nструктуры. Использовано два способа присваивания значений. Первый способ\nобычное присваивание через знак равно. Второй способ – это копирование\nстроки в переменную. Нетрудно заметить, что сначала написано имя объекта,\nпотом индекс массива и через точку идет обращение к переменной описанной\nвнутри структуры.\n Иногда известно сколько элементов должен содержать массив и в задачах по\nпрограммированию можно увидеть такие слова: “Создать массив из N\nструктур” и т.п. В простых задачах ничего сложного нет. Часто студенты\nпредлагают ввести N с клавиатуры и при вводе этого N создают массив\nструктур из N элементов.\nPHP\nMyStruct *obj1; //obj1 есть указатель на MyStruct;\nint N; //N есть число элементов массива\ncin>>N; //Присваивание в N значения\nobj1=new MyStruct[N]; //Динамическое выделение памяти под массив\nструктур из N элементов\n //Некоторый код\ndelete []obj1; //Освобождение памяти\n Когда массив структур состоит из некоторого множества элементов, то для\nработы как и с обычным массивом используют циклы. Думаю имеет смысл\nразбивать ввод данных и вывод данных в отдельные функции. В приведенном\nниже примере будет создана простая структура, которая представляет собой\nтип данных Продуктовый магазин. \n40\n Продуктовый магазин представляет из себя одно целое. В магазине могут\nпродавать разные продукты. У каждого продукта есть название, есть цена. В\nмагазине есть разные продавцы, которые продают товар. К каждому продавцу\nподходит покупатель, который покупает товар. Можно долго и много\nрасписывать что происходит на самом деле., но я остановлюсь на том что\nнаписал.\nЧтобы объяснить компилятору что нам нужно, стоит навести некоторый\nпорядок в вышеизложенном.Я разобью на поэтапное изложение кода, чтобы\nбольшинство трудных читателей попробовали понять суть.\nПродуктовый магазин\nPHP\n1\n2\n3 struct Shop\n{\n Определились с обобщенным названием нашей структуры.\nВсё что есть в магазине можно объединить под названием нужные данные.\nPHP\nstruct Shop\n{\nchar name[20]; //Название про\nfloat cena; //Цена продукта\nДата продажи описана как массив из трех целочисленных чисел. Остальным\nпеременным соответствуют различные типы, удобные для обработки\nпеременных. После того как определились и описали нужную структуру\nобязательно создается переменная, тип которой есть имя структуры. Вводятся\nданные в элементы структуры. Нижеприведенный код это всё то что написано\nчуть выше.\nPHP\n#include <iostream>\n/*ОПИСЫВАЕМАЯСТРУКТУРА*/\n struct Shop\n {\n char name[20];\n int cena;\n char prodav[30];\n char pokup[30];\n int date[3];\n };\n/*ГЛАВНАЯФУНКЦИЯ*/\nint main() \n{\n int N;\n cout<<\"Введи N: \";\n cin>>N;\n Shop *M1=new Shop[10]; //Выделение памяти под массив структур из 10 элементов\n delete []M1; //Освобождение памяти\n cin.get(); //Ожидание нажатия клавиши\n return 0;\n}\nСам по себе такой код большого смысла не имеет, это всего лишь\nподготовительная часть для работы с массивом структур.Дальше необходимо\nобеспечить ввод данных в элементы массива структур. Ввод и вывод данных\nудобно обеспечивать через отдельные функции, т.к. нередко создаются\nпользовательские меню с возможностью выбора обработки структур.\nСтруктура очень похожа на массив и передается вовнутрь функции таким же\nобразом. Можно использовать указатель и нужно сделать так, чтоб функция\nзнала размер массива структур. Размер массива структур функции нужно знать\nдля того, чтобы циклы обработки массива структур знали конечную точку\nсвоего выполнения.\nvoid GetData(Shop *M,int N)\n{\n}\n//Первый параметр – указатель на тип Shop. "
		}
	]
}