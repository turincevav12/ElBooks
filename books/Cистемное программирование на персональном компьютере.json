{
	"name": "Cистемное программирование на персональном компьютере",
	"textBook": [
		{
			"abzac": "Лекция 1. Основные понятия и определения",
			"textAbzac": ""
		},
		{
			"abzac": "Программы и программное обеспечение",
			"textAbzac": "Программа — это данные, предназначенные для управления кон кретными компонентами системы обработки информации (СОИ) в це лях реализации определенного алгоритма.\n\nОбратить внимание: программа — это данные.\n\nОдин из основных принципов машины фон Неймана — то, что и программы, и данные хранятся в одной и той же памяти. Сохраняемая в памяти программа представляет собой некоторые коды, которые могут рассматриваться как данные. Возможно, с точки зрения программиста программа — активный компонент, она выполняет некоторые действия. Но с точки зрения процессора команды программы — это данные, кото рые процессор читает и интерпретирует. С другой стороны программа — это данные с точки зрения обслуживающих программ, например, с точ ки зрения компилятора, который на входе получает одни данные — про грамму на языке высокого уровня (ЯВУ), а на выходе выдает другие дан ные — программу в машинных кодах.\n\nПрограммное обеспечение (ПО) — совокупность программ СОИ и программных документов, необходимых для их эксплуатации\n\nСущественно, что ПО — это программы, предназначенные для многократного использования и применения разными пользователями. В связи с этим следует обратить внимание на ряд необходимых свойств ПО.\n\nНеобходимость документирования\n\nПо определению программы становятся ПО только при наличии документации. Конечный пользователь не может работать, не имея доку ментации. Документация делает возможным тиражирование ПО и про дажу его без его разработчика. По Бруксу ошибкой в ПО является ситуа ция, когда программное изделие функционирует не в соответствии со своим описанием, следовательно, ошибка в документации также являет ся ошибкой в программном изделии.\n\nЭффективность\n\nПО, рассчитанное на многократное использование (например, ОС, текстовый редактор) пишется и отлаживается один раз, а выполня ется многократно. Таким образом, выгодно переносить затраты на этап производства ПО и освобождать от затрат этап выполнения, чтобы избе жать тиражирования затрат.\n\nНадежность\n\nВ том числе:\n\nТестирование программы при всех допустимых спецификациях входных данных\n\nЗащита от неправильных действий пользователя\n\nЗащита от взлома — пользователи должны иметь возможность взаимодействия с ПО только через легальные интерфейсы.\n\nПоявление ошибок любого уровня не должно приводить к краху системы. Ошибки должны вылавливаться диагностироваться и (если их невозможно исправить) превращаться в корректные отказы.\n\nСистемные структуры данных должны сохраняться безусловно.\n\nСохранение целостности пользовательских данных желательно.\n\nВозможность сопровождения\n\nВозможные цели сопровождения — адаптация ПО к конкретным условиям применения, устранение ошибок, модификация.\n\nВо всех случаях требуется тщательное структурирование ПО и но сителем информации о структуре ПО должна быть программная доку ментация.\n\nАдаптация во многих случаях может быть передоверена пользова телю — при тщательной отработке и описании сценариев инсталляции и настройки.\n\nИсправление ошибок требует развитой сервисной службы, со бирающей информацию об ошибках и формирующей исправляющие пакеты.\n\nМодификация предполагает изменение спецификаций на ПО. При этом, как правило, должны поддерживаться и старые специфика ции. Эволюционное развитие ПО экономит вложения пользователей."
		},
		{
			"abzac": "Системное программирование",
			"textAbzac": "Системная программа — программа, предназначенная для поддер жания работоспособности СОИ или повышения эффективности ее ис пользования.\n\nПрикладная программа — программа, предназначенная для реше ния задачи или класса задач в определенной области применения СОИ.\n\nВ соответствии с терминологией, системное программирование — это процесс разработки системных программ (в том числе, управляющих\n\nиобслуживающих).\n\nСдругой стороны, система — единое целое, состоящее из множе ства компонентов и множества связей между ними. Тогда системное программирование — это разработка программ сложной структуры.\n\nЭти два определения не противоречат друг другу, так как разра ботка программ сложной структуры ведется именно для обеспечения ра ботоспособности или повышения эффективности СОИ.\n\nПодразделение ПО на системное и прикладное является до неко торой степени устаревшим. Сегодняшнее деление предусматривает по меньшей мере три градации ПО:\n\nСистемное\n\nПромежуточное\n\nПрикладное\n\nПромежуточное ПО (middleware) мы определяем как совокуп ность программ, осуществляющих управление вторичными (конструи руемыми самим ПО) ресурсами, ориентированными на решение опреде ленного (широкого) класса задач. К такому ПО относятся менеджеры транзакций, серверы БД, серверы коммуникаций и другие программные серверы. С точки зрения инструментальных средств разработки проме жуточное ПО ближе к прикладному, так как не работает на прямую с первичными ресурсами, а использует для этого сервисы, предоставляе мые системным ПО.\n\nС точки зрения алгоритмов и технологий разработки промежуточ ное ПО ближе к системному, так как всегда является сложным про граммным изделием многократного и многоцелевого использования и в нем применяются те же или сходные алгоритмы, что и в системном ПО.\n\nСовременные тенденции развития ПО состоит в снижении объе ма как системного, так и прикладного программирования. Основная часть работы программистов выполняется в промежуточном ПО. Сни жение объема системного программирования определено современны ми концепциями ОС, объектно ориентированной архитектурой и архи тектурой микроядра, в соответствии с которыми большая часть функций системы выносится в утилиты, которые можно отнести и к промежуточ ному ПО. Снижение объема прикладного программирования обусловле но тем, что современные продукты промежуточного ПО предлагают все больший набор инструментальных средств и шаблонов для решения за дач своего класса.\n\nЗначительная часть системного и практически все прикладное ПО пишется на языках высокого уровня, что обеспечивает сокращение рас ходов на их разработку/модификацию и переносимость.\n\nСистемное ПО подразделяется на системные управляющие про граммы и системные обслуживающие программы.\n\nУправляющая программа — системная программа, реализующая набор функций управления, который включает в себя управление ресур сами и взаимодействие с внешней средой СОИ, восстановление работы системы после проявления неисправностей в технических средствах.\n\nПрограмма обслуживания (утилита) — программа, предназначен ная для оказания услуг общего характера пользователям и обслуживаю щему персоналу СОИ.\n\nУправляющая программа совместно с набором необходимых для эксплуатации системы утилит составляют операционную систему (ОС).\n\nКроме входящих в состав ОС утилит могут существовать и другие утилиты (того же или стороннего производителя), выполняющие допол нительное (опционное) обслуживание. Как правило, это утилиты, обес печивающие разработку программного обеспечения для операционной системы.\n\nСистема программирования — система, образуемая языком про граммирования, компилятором или интерпретатором программ, пред ставленных на этом языке, соответствующей документацией, а также вспомогательными средствами для подготовки программ к форме, при годной для выполнения."
		},
		{
			"abzac": "Этапы подготовки программы",
			"textAbzac": "При разработке программ, а тем более — сложных, используется принцип модульности, разбиения сложной программы на составные ча сти, каждая из которых может подготавливаться отдельно. Модульность является основным инструментом структурирования программного из делия, облегчающим его разработку, отладку и сопровождение.\n\nПрограммный модуль — программа или функционально завершен ный фрагмент программы, предназначенный для хранения, трансляции, объединения с другими программными модулями и загрузки в оператив ную память.\n\nПри выборе модульной структуры должны учитываться следую щие основные соображения:\n\nФункциональность — модуль должен выполнять законченную функцию\n\nНесвязность — модуль должен иметь минимум связей с другими модулями, связь через глобальные переменные и области памяти нежелательна\n\nСпецифицируемость — входные и выходные параметры модуля должны четко формулироваться\n\nПрограмма пишется в виде исходного модуля.\n\nИсходный модуль — программный модуль на исходном языке, об рабатываемый транслятором и представляемый для него как целое, до статочное для проведения трансляции.\n\nПервым (не для всех языков программирования обязательным) этапом подготовки программы является обработка ее Макропроцессо ром (или Препроцессором). Макропроцессор обрабатывает текст программы и на выходе его получается новая редакция текста. В боль шинстве систем программирования Макропроцессор совмещен с транс лятором, и для программиста его работа и промежуточный ИМ «не вид ны».\n\nСледует иметь в виду, что Макропроцессор выполняет обработку текста, это означает, с одной стороны, что он «не понимает» операторов языка программирования и «не знает» переменных программы, с другой, что все операторы и переменные Макроязыка (тех выражений в про грамме, которые адресованы Макропроцессору) в промежуточном ИМ уже отсутствуют и для дальнейших этапов обработки «не видны».\n\nТак, если Макропроцессор заменил в программе некоторый текст A на текст B, то транслятор уже видит только текст B, и не знает, был этот текст написан программистом «своей рукой» или подставлен Макропро цессором.\n\nСледующим этапом является трансляция.\n\nТрансляция — преобразование программы, представленной на од ном языке программирования, в программу на другом языке программи рования, в определенном смысле равносильную первой.\n\nКак правило, выходным языком транслятора является машинный язык целевой вычислительной системы. (Целевая ВС — та ВС, на кото рой программа будет выполняться.)\n\nМашинный язык — язык программирования, предназначенный для представления программы в форме, позволяющей выполнять ее не посредственно техническими средствами обработки информации.\n\nТрансляторы — общее название для программ, осуществляющих трансляцию. Они подразделяются на Ассемблеры и Компиляторы — в зависимости от исходного языка программы, которую они обрабатыва ют. Ассемблеры работают с Автокодами или языками Ассемблера, Ком пиляторы — с языками высокого уровня.\n\nАвтокод — символьный язык программирования, предложения которого по своей структуре в основном подобны командам и обрабаты ваемым данным конкретного машинного языка.\n\nЯзык Ассемблера — язык программирования, который представ ляет собой символьную форму машинного языка с рядом возможностей, характерных для языка высокого уровня (обычно включает в себя макро средства).\n\nЯзык высокого уровня — язык программирования, понятия и структура которого удобны для восприятия человеком.\n\nОбъектный модуль — программный модуль, получаемый в резуль тате трансляции исходного модуля.\n\nПоскольку результатом трансляции является модуль на языке, близком к машинному, в нем уже не остается признаков того, на каком исходном языке был написан программный модуль. Это создает принци пиальную возможность создавать программы из модулей, написанных на разных языках. Специфика исходного языка, однако, может сказываться на физическом представлении базовых типов данных, способах обраще ния к процедурам/функциям и т.п. Для совместимости разноязыковых модулей должны выдерживаться общие соглашения. Большая часть объ ектного модуля — команды и данные машинного языка именно в той форме, в какой они будут существовать во время выполнения програм мы. Однако, программа в общем случае состоит из многих модулей. По скольку транслятор обрабатывает только один конкретный модуль, он не может должным образом обработать те части этого модуля, в которых за программированы обращения к данным или процедурам, определенным в другом модуле. Такие обращения называются внешними ссылками. Те места в объектном модуле, где содержатся внешние ссылки, транслиру ются в некоторую промежуточную форму, подлежащую дальнейшей об работке. Говорят, что объектный модуль представляет собой программу на машинном языке с неразрешенными внешними ссылками. Разреше ние внешних ссылок выполняется на следующем этапе подготовки, ко торый обеспечивается Редактором Связей (Компоновщиком). Редактор Связей соединяет вместе все объектные модули, входящие в программу. Поскольку Редактор Связей «видит» уже все компоненты программы, он имеет возможность обработать те места в объектных модулях, которые содержат внешние ссылки. Результатом работы Редактора Связей явля ется загрузочный модуль.\n\nЗагрузочный модуль — программный модуль, представленный в форме, пригодной для загрузки в оперативную память для выполнения.\n\nЗагрузочный модуль сохраняется в виде файла на внешней памя ти. Для выполнения программа должна быть перенесена (загружена) в оперативную память. Иногда при этом требуется некоторая дополни тельная обработка (например, настройка адресов в программе на ту об ласть оперативной памяти, в которую программа загрузилась). Эта функция выполняется Загрузчиком, который обычно входит в состав опера ционной системы. Возможен также вариант, в котором редактирование связей выполняется при каждом запуске программы на выполнение и совмещается с загрузкой. Это делает Связывающий Загрузчик. Вариант связывания при запуске более расходный, т.к. затраты на связывание ти ражируются при каждом запуске. Но он обеспечивает:\n\nбольшую гибкость в сопровождении, так как позволяет менять отдельные объектные модули программы, не меняя остальных модулей;\n\nэкономию внешней памяти, т.к. объектные модули, используемые во многих программах не копируются в каждый загрузочный модуль, а хранятся в одном экземпляре.\n\nВариант интерпретации подразумевает прямое исполнение исход ного модуля.\n\nИнтерпретация — реализация смысла некоторого синтаксически законченного текста, представленного на конкретном языке.\n\nИнтерпретатор читает из исходного модуля очередное предложе ние программы, переводит его в машинный язык и выполняет. Все затра ты на подготовку тиражируются при каждом выполнении, следователь но, интерпретируемая программа принципиально менее эффективна, чем транслируемая. Однако, интерпретация обеспечивает удобство раз работки, гибкость в сопровождении и переносимость.\n\nНе обязательно подготовка программы должна вестись на той же вычислительной системе и в той же операционной среде, в которых про грамма будет выполняться. Системы, обеспечивающие подготовку про грамм в среде, отличной от целевой называются кросс системами. В кросс системе может выполняться вся подготовка или ее отдельные этапы:\n\nМакрообработка и трансляция\n\nРедактирование связей\n\nОтладка\n\nТиповое применение кросс систем — для тех случаев, когда целе вая вычислительная среда просто не имеет ресурсов, необходимых для подготовки программ, например, встроенные системы. Программные средства, обеспечивающие отладку программы на целевой системе мож но также рассматривать как частный случай кросс системы."
		},
		{
			"abzac": "Лекция 2. Ассемблеры",
			"textAbzac": ""
		},
		{
			"abzac": "Программирование на языке Ассемблера",
			"textAbzac": "Язык Ассемблера — система записи программы с детализацией до отдельной машинной команды, позволяющая использовать мнемониче ское обозначение команд и символическое задание адресов.\n\nПоскольку в разных аппаратных архитектурах разные программ но доступные компоненты (система команд, регистры, способы адреса ции), язык Ассемблера аппаратно зависимый. Программы, написанные на языке Ассемблера могут быть перенесены только на вычислительную систему той же архитектуры.\n\nПрограммирование на языке Ассемблера позволяет в максималь ной степени использовать особенности архитектуры вычислительной системы. До недавнего времени воспринималась как аксиома, что ассем блерная программа всегда является более эффективной и в смысле быс тродействия, и в смысле требований к памяти. Для Intel архитектуры это и сейчас так.\n\nНо это уже не так для RISK архитектур. Для того, чтобы програм ма могла эффективно выполняться в вычислительной среде с распарал леливанием на уровне команд, она должна быть определенным образом оптимизирована, то есть, команды должны быть расположены в опреде ленном порядке, допускающим их параллельное выполнение. Програм мист просто не сможет покомандно оптимизировать всю свою програм му. С задачей такой оптимизации более эффективно справляются компиляторы.\n\nДоля программ, которые пишутся на языках Ассемблеров в мире, неуклонно уменьшается, прикладное программирование на языках Ас семблеров применяется только по недомыслию. Язык Ассемблера «в чи стом виде» применяется только для написания отдельных небольших частей системного ПО: микроядра ОС, самых нижних уровней драйверов\n\n— тех частей, которые непосредственно взаимодействуют с реальными аппаратными компонентами.\n\nЭтим занимается узкий круг программистов, работающих в фир мах, производящих аппаратуру и ОС. Зачем же нам тогда изучать постро ение Ассемблера?\n\nХотя разработка программ, взаимодействующих с реальными ап паратными компонентами, — редкая задача, в современном программи ровании при разработке прикладного, а еще более — промежуточного ПО довольно часто применяется технологии виртуальных машин. Для выполнения того или иного класса задач программно моделируется не которое виртуальное вычислительное устройство, функции которого со ответствуют нуждам этого класса задач.\n\nДля управления таким устройством для него может быть создан соответствующий язык команд. (Широко известные примеры: MI AS/400, JVM.) Говоря шире, любую программу можно представить себе как виртуальное «железо», решающее конкретную задачу. (Конечный пользователь обычно не видит разницы между программой и аппарату рой и часто говорит не «мне программа выдала то то», а «мне компьютер выдал то то»). В некоторых случаях интерфейс программы удобно представить в виде системы команд, а следовательно, нужен соответству ющий Ассемблер. (Это, конечно, относится не к программам «для чай ников», а к инструментальным средствам программистов, системам мо делирования).\n\n"
		},
		{
			"abzac": "Предложения языка Ассемблера",
			"textAbzac": "Предложения языка Ассемблера описывают команды или псевдо команды (директивы). Предложения команды задают машинные ко манды вычислительной системы; обработка Ассемблером команды при водит к генерации машинного кода. Обработка псевдокоманды не приводит к непосредственной генерации кода, псевдокоманда управляет работой самого Ассемблера. Для одной и той же аппаратной архитектуры могут быть построены разные Ассемблеры, в которых команды будут обязательно одинаковые, но псевдокоманды могут быть разные.\n\nВо всех языках Ассемблеров каждое новое предложение языка на чинается с новой строки. Каждое предложение, как правило, занимает одну строку, хотя обычно допускается продолжение на следующей стро ке/строках. Формат записи предложений языка м.б. жесткий или свобод ный. При записи в жестком формате составляющие предложения долж ны располагаться в фиксированных позициях строки. (Например: метка должна располагаться в позициях 1 8, позиция 9 — пустая, позиции 10 12 — мнемоника команды, позиция 13 — пустая, начиная с позиции 14 — операнды, позиция 72 — признак продолжения). Обычно для записи программ при жестком формате создаются бланки. Жесткий формат удо бен для обработки Ассемблером (удобен и для чтения).\n\nСвободный формат допускает любое количество пробелов между составляющими предложения.\n\nВ общих случаях предложения языка Ассемблера состоят из следу ющих компонент:\n\nметка или имя;\n\nмнемоника;\n\nоперанды;\n\nкомментарии.\n\nМетка или имя является необязательным компонентом. Не во всех языках Ассемблеров эти понятия различаются. Если они различают ся (например, MASM), то метка — точка программы, на которую переда ется управление, следовательно, метка стоит в предложении, содержа щем команду; имя — имя переменной программы, ячейки памяти, следовательно, имя стоит в предложении, содержащем псевдокоманду резервирования памяти или определения константы. В некоторых случа ях метка и имя могут отличаться даже синтаксически, так, в MASM/ TASM после метки ставится двоеточие, а после имени — нет.\n\nОднако, физический смысл и метки, и имени — одинаков, это — адрес памяти. Во всех случаях, когда Ассемблер встречает в программе имя или метку, он заменяет ее на адрес той ячейки памяти, к которую имя/метка именует.\n\nПравила формирования имен/меток совпадают с таковыми для языков программирования. В некоторых Ассемблерах (HLAM S/390) не делается различия между меткой и именем.\n\nВ языке должны предусматриваться некоторые специальные пра вила, позволяющие Ассемблеру распознать и выделить метку/имя, на пример:\n\nметка/имя должна начинаться в 1 й позиции строки\n\nесли метки/имени нет, то в 1 й позиции должен быть пробел, или за меткой/именем должно следовать двоеточие, и т.п.\n\nМнемоника — символическое обозначение команды/псевдоко манды.\n\nОперанды — один или несколько операндов, обычно разделяемые запятыми. Операндами команд являются имена регистров, непосред ственные операнды, адреса памяти (задаваемые в виде констант, литера лов, символических имен или сложных выражений, включающих специальный синтаксис). Операнды псевдокоманд могут быть сложнее и разнообразнее.\n\nКомментарии — любой текст, который игнорируется Ассемблером. Комментарии располагаются в конце предложения и отделяются от тек ста предложения, обрабатываемого Ассемблером, каким либо специаль ным символом (в некоторых языках — пробелом). Всегда предусматри вается возможность строк, содержащих только комментарий, обычно такие строки содержат специальный символ в 1 й позиции.\n\nКонстанты — могут представлять непосредственные операнды или абсолютные адреса памяти. Применяются 10 е, 8 е, 16 е, 2 е, символь ные константы.\n\nНепосредственные операнды — записываются в сам код команды.\n\nИмена — адреса ячеек памяти.\n\nПри трансляции Ассемблер преобразует имена в адреса. Способ преобразования имени в значение зависит от принятых способов адреса ции. Как правило, в основным способом адресации в машинных языках является адресация относительная: адрес в команде задается в виде сме щения относительно какого то базового адреса, значение которого со держится в некотором базовом регистре. В качестве базового могут при меняться либо специальные регистры (DS, CS в Intel) или регистры общего назначения (S/390).\n\nЛитералы — записанные в особой форме константы. Концепту ально литералы — те же имена. При появлении в программе литерала Ас семблер выделяет ячейку памяти и записывает в нее заданную в литерале константу. Далее все появления этого литерала Ассемблер заменяет на обращения по адресу этой ячейки. Таким образом, литеральные кон станты, хранятся в памяти в одном экземпляре, независимо от числа об ращений к ним.\n\nСпециальный синтаксис — явное описание способа адресации (на пример, указание базового регистра и смещения)."
		},
		{
			"abzac": "Регистры",
			"textAbzac": "Программа в машинном коде состоит из различных сегментов для определения данных, для машинных команд и для сегмента, названного стеком, для хранения адресов. Для выполнения арифметических дейст вий, пересылки данных и адресации компьютер имеет ряд регистров.\n\nДля выполнения программ компьютер временно записывает про грамму и данные в основную память. Компьютер имеет также ряд pегис тров, которые он использует для временных вычислений."
		},
		{
			"abzac": "Биты и байты",
			"textAbzac": "Минимальной единицей информации в компьютере является бит. Бит может быть выключен, так что его значение есть нуль, или включен, тогда его значение равно единице. Единственный бит не может предста вить много информации в отличие от группы битов.\n\nГруппа из девяти битов представляет собой байт; восемь битов ко торого содержат данные и один бит — контроль на четность. Восемь би тов обеспечивают основу для двоичной арифметики и для представления символов, таких как буква A или символ *. Восемь битов дают 256 раз личных комбинаций включенных и выключенных состояний: от «все вы ключены» (00000000) до «все включены» (11111111). Например, сочета ние включенных и выключенных битов для представления буквы A выглядит как 01000001, а для cимвола * — 00101010 (это можно не запо минать). Каждый байт в памяти компьютера имеет уникальный адрес, начиная с нуля."
		},
		{
			"abzac": "ASCII",
			"textAbzac": "Для целей стандартизации в микрокомпьютерах используется aмериканский национальный стандартный код для обмена информаци ей ASCII (American National Standard Code for Information Interchange). Читается как «аски» код. Именно по этой причине комбинация бит 01000001 обозначает букву A.\n\nНаличие стандартного кода облегчает обмен данными между раз личными устройствами компьютера. 8 битовый расширенный ASCII код, используемый в PC обеспечивает представление 256 символов, включая символы для национальных алфавитов."
		},
		{
			"abzac": "Двоичные числа",
			"textAbzac": "Так как компьютер может различить только нулевое и единичное состояние бита, то он работает системе исчисления с базой 2 или в дво ичной системе. Фактически бит унаследовал cвое название от англий ского «Binary digit» (двоичная цифра).\n\nСочетанием двоичных цифр (битов) можно представить любое значение. Значение двоичного числа определяется относительной пози цией каждого бита и наличием единичных битов.\n\nСамый правый бит имеет весовое значение 1, следующая цифра влево — 2, следующая — 4 и так далее. Общая сумма для восьми единич ных битов в данном случае составит 1+2+4+...+128, или 255 (2 в восьмой степени — 1).\n\nДля двоичного числа 01000001 единичные биты представляют зна чения 1 и 64, то есть, 65. Но 01000001 представляет также букву A! Дейст вительно, здесь момент, который необходимо четко уяснить. Биты 01000001 могут представлять как число 65, так и букву A:\n\nесли программа определяет элемент данных для арифметических целей, то 01000001 представляет двоичное число эквивалентное десятичному числу 65;\n\nесли программа определяет элемент данных (один или более смежных байт), имея в виду описательный характер, как, например, заголовок, тогда 01000001 представляет собой букву или «строку».\n\nПри программировании это различие становится понятным, так как назначение каждого элемента данных определено.\n\nДвоичное число не ограничено только восемью битами. Процес сор может использовать 16 битовую архитектуру, в этом случае он авто матически оперирует с 16 битовыми числами. 2 в степени 16 минус 1 дает значение 65535, а немного творческого программирования позволит обрабатывать числа до 32 бит (2 в степени 32 минус 1 равно 4294967295) и даже больше.\n\nДвоичная арифметика\n\nКомпьютер выполняет арифметические действия только в двоич ном формате. Поэтому программист на языке Ассемблера должен быть знаком с двоичным форматом и двоичным сложением:0+ 0= 0\n 1+ 0= 1\n1+1=10\n\n \n\n1+1+1= 11\n\nОтрицательные числа\n\nВсе представленные выше двоичные числа имеют положительные значения, что обозначается нулевым значением самого левого (старше го) разряда. Отрицательные двоичные числа содержат единичный бит в старшем разряде и выражаются двоичным дополнением. То есть, для представления отрицательного двоичного числа необходимо инвертиро вать все биты и прибавить 1.\n\nРассмотрим пример:\n\nЧисло 65: 01000001\n\nИнверсия: 10111110\n\nПлюс 1: 10111111 (равно 65).\n\nВ случае, если прибавить единичные значения к числу 10111111, 65 не получится.\n\nФактически двоичное число считается отрицательным, если его старший бит равен 1. Для определения абсолютного значения отрица тельного двоичного числа, необходимо повторить предыдущие опера ции: инвертировать все биты и прибавить 1:\n\nДвоичное значение: 10111111\n\nИнверсия: 01000000\n\nПлюс 1: 01000001 (равно +65).\n\nСумма +65 и 65 должна составить ноль:\n\n01000001 (+65) + 10111111 ( 65) = (1) 00000000\n\nВсе восемь бит имеют нулевое значение. Перенос единичного би та влево потерян. Однако, если был перенос в знаковый pазряд и из раз рядной сетки, то результат является корректным.\n\nДвоичное вычитание выполняется просто: инвертируется знак вычитаемого и складываются два числа. Вычтем, например, 42 из 65. Двоичное представление для 42 есть 00101010, и его двоичное дополне ние: — 11010110:\n\n65 01000001 +( 42) 11010110 = 23 (1) 00010111\n\nРезультат 23 является корректным. В рассмотренном примере произошел перенос в знаковый разряд и из разрядной сетки.\n\nВ случае, если справедливость двоичного дополнения не сразу по нятна, рассмотрим следующие задачи: Какое значение необходимо при бавить к двоичному числу 00000001, чтобы получить число 00000000? В терминах десятичного исчисления ответом будет 1. Для двоичного рас смотрим 11111111:\n\n00000001 11111111 Результат: (1) 00000000\n\nИгнорируя перенос (1), можно видеть, что двоичное число 11111111 эквивалентно десятичному 1 и соответственно:\n\n0 00000000 (+1) 00000001 1 11111111\n\nМожно видеть также каким образом двоичными числами предcтавлены уменьшающиеся числа:\n\n+3 00000011\n\n+2 00000010\n\n+1 00000001\n\n0 00000000\n\n1 11111111\n\n2 11111110\n\n3 11111101\n\nФактически нулевые биты в отрицательном двоичном числе опре деляют его величину: рассмотрите позиционные значения нулевых битов как если это были единичные биты, сложите эти значения и прибавьте единицу.\n\n"
		},
		{
			"abzac": "Шестнадцатеричное представление",
			"textAbzac": "Представим, что необходимо просмотреть содержимое некотоpых байт в памяти. Требуется oпределить содержимое четырех последова тельных байт (двух слов), которые имеют двоичные значения. Так как че тыре байта включают в себя 32 бита, то специалисты разработали «стено графический» метод представления двоичных данных. По этому методу каждый байт делится пополам и каждые полбайта выражаются соответ ствующим значением. Рассмотрим следующие четыре байта:\n\nДвоичное:\n\n0101 1001 0011 0101 1011 1001 1100 1110\n\nДесятичное:\n\n5\n\n9\n\n3\n\n5\n\n11\n\n9\n\n12\n\n14\n\nТак как здесь для некоторых чисел требуется две цифры, расши рим систему счисления так, чтобы 10=A, 11=B, 12=C, 13=D, 14=E, 15=F. Таким образом получим более сокращенную форму, которая представ ляет содержимое вышеуказанных байт:\n\n59 35 B9 CE\n\nТакая система счисления включает «цифры» от 0 до F, и так как таких цифр 16, она называется шестнадцатеричным представлениeм.\n\nШестнадцатеричный формат нашел большое применение в языке Ассемблера. В листингах ассемблирования программ в шестнадцатерич ном формате показаны все адреса, машинные коды команд и содержи мое констант. Также для отладки при использовании программы DOS DEBUG адреса и содержимое байтов выдается в шестнадцатеричном формате.\n\nВ случае, если немного поработать с шестнадцатеричным форма том, то можно быстро привыкнуть к нему. Рассмотрим несколько простых примеров шестнадцатеричной арифметики. Следует помнить, что после шестнадцатеричного числа F следует шестнадцатеричное 10, что равно десятичному числу 16.\n\nЗаметьте также, что шестнадцатеричное 20 эквивалентно десятич ному 32, шестнадцатеричное 100 — десятичному 256 и шестнадцатерич ное 100 — десятичному 4096.\n\nШестнадцатеричные числа записываются, например, как шест. 4B, двоичные числа какдв.01001011, а десятичные числа, как75 (отсутствие какого либо описания предполагает десятичное число). Для инди кации шестнадцатеричные числа в ассемблерной программе непосредст венно после числа ставится символ H, например,25H (десятичное значе ние 37). Шестнадцатеричное число всегда начинается с деcятичной цифры от 0 до 9, таким образом,B8H записывается как0B8H."
		},
		{
			"abzac": "Сегменты",
			"textAbzac": "Сегментом называется область, которая начинается на границе параграфа, то есть, по любому адресу, который делится на 16 без остатка. Хотя сегмент может располагаться в любом месте памяти и иметь размер до 64 Кбайт, он требует столько памяти, cколько необходимо для выпол нения программы.\n\nСегмент кодов\n\nСегмент кодов содержит машинные команды, которые будут вы полняться. Обычно первая выполняемая команда находится в начале этого сегмента и операционная система передает управление по адресу данного сегмента для выполнения программы.\n\nРегистр сегмента кодов (CS) адресует данный сегмент.\n\nСегмент данных\n\nСегмент данных содержит определенные данные, константы и ра бочие области, необходимые программе. Регистр сегмента данных (DS) адресует данный сегмент.\n\nСегмент стека\n\nСтек содержит адреса возврата как для программы для возврата в операционную систему, так и для вызовов подпрограмм для возврата в главную программу. Регистр сегмента стека (SS) адресует данный сег мент.\n\nЕще один сегментный регистр, регистр дополнительного сегмента (ES), предназначен для специального использования. Последователь ность регистров и сегментов на практике может быть иной.\n\nТри сегментных регистра содержат начальные адреса соответству ющих сегментов и каждый сегмент начинается на границе параграфа.\n\nВнутри программы все адреса памяти относительны к началу cег мента. Такие адреса называются смещением от начала сегмента. Двух байтовое смещение (16 бит) может быть в пределах от шест.0000 до шест.FFFF или от 0 до 65535. Для обращения к любому адресу в програм ме, компьютер складывает адрес в регистре сегмента и смещение. На пример, первый байт в сегменте кодов имеет смещение 0, второй байт — 01 и так далее до смещения 65535.\n\nВ качестве примера адресации, допустим, что регистр сегмента данных содержит шест.045F и некоторая команда обращается к ячейке памяти внутри сегмента данных со смещением 0032. Несмотpя на то, что регистр сегмента данных содержит 045F, он указывает на адрес 045F0, то есть, на границе параграфа. Действительный адрес памяти поэтому будет следующий:\n\nАдрес в DS: 045F0\n\nСмещение: 0032\n\nРеальный адрес: 04622\n\nКаким образом процессоры адресуют память в один миллион байт?\n\nВ регистре содержится 16 бит. Так как адрес сегмента всегда на границе параграфа, младшие четыре бита адреса pавны нулю.\n\nШест.FFF0 позволяет адресовать до 65520 (плюс смещение) байт. Но специалисты решили, что нет смысла иметь место для битов, которые всегда равны нулю.\n\nПоэтому адрес хранится в cегментном регистре как шест. nnnn, а компьютер полагает, что имеются еще четыре нулевых младших бита (одна шест. цифра), то есть, шест.nnnn0. Таким образом, шест.FFFF0 позволяет адресовать до 1048560 байт.\n\nВ случае, если вы сомневаeтесь, то декодируйте каждое шест.F как двоичное 1111, учтите нулевые биты и сложите значения для единичных бит.\n"
		},
		{
			"abzac": "Расширение набора команд",
			"textAbzac": "Команды делятся на следующие группы:\n\nарифметические;\n\nлогические;\n\nпередачи данных;\n\nперехода;\n\nпропуска;\n\nвызова подпрограммы;\n\nвозврата из подпрограммы;\n\nсмешанные.\n\nТипы операндов для каждого типа команд обсуждаются в соответ ствующем порядке:\n\nбайт;\n\nслово;\n\nдесятичный операнд;\n\nразряд;\n\nчисло;\n\nсоставной операнд.\n\nПри обсуждении способов адресации используется следующий порядок:\n\nпрямая;\n\nкосвенная;\n\nнепосредственная;\n\nиндексная;\n\nрегистровая;\n\nавтоиндексирование с предварительным увеличением адреса;\n\nавтоиндексирование с предварительным уменьшением адреса;\n\nавтоиндексирование с последующем уменьшением адреса;\n\nкосвенная с предварительным индексированием;\n\nкосвенная с последующем индексированием.\n\nАрифметические команды\n\nВ эту группу включены следующие команды:\n\nсложение;\n\nсложение с флагом переноса;\n\nвычитание;\n\nвычитание при перестановке операндов;\n\nвычитание с флагом переноса (заем);\n\nувеличение на 1;\n\nуменьшение на 1;\n\nумножение;\n\nделение;\n\nсравнение;\n\nполучение дополнения до двух (отрицательного числа);\n\nрасширение.\n\nДля удобства те команды, принадлежность которых к конкретной категории неясна, повторяются во всех категориях, к которым они мог ли бы быть отнесены.\n\nЛогические команды\n\nЭта группа включает следующие команды:\n\nлогическое И\n\nлогическое ИЛИ\n\nлогическое исключающее ИЛИ\n\nлогическое НЕ (дополнение)\n\nсдвиг\n\nциклический сдвигпроверку.\n\nОна включает также те арифметические команды (такие, как сло жение с аккумулятора с самим собой), которые выполняют логические функции.\n\nКоманды передачи данных\n\nЭта группа включает команды:\n\nзагрузки;\n\nзапоминания;\n\nпересылки;\n\nобмена;\n\nввода;\n\nвывода;\n\nочистки;\n\nустановки.\n\nКроме того, она включает арифметические команды (такие как вычитание аккумулятора из самого себя), которые заносят определенное значение или содержимое какого либо регистра в аккумулятора или дру гой регистр назначения, не изменяя при этом данных.\n\nКоманды перехода\n\nЭта группа включает следующие виды переходов:\n\nКоманды безусловного перехода\n\nПерейти косвенно;\n\nПерейти по индексу, предполагая, что базовый адрес таблицы адресов находится в регистрах Н иL, а индекс в аккумуляторе;\n\nПерейти и связать, то есть, передать управление по адресу DEST, сохранив текущее состояние счетчика команд в регистрахН иL.\n\nКоманды условного перехода\n\nПерейти при равенстве нулю;\n\nПерейти при неравенстве нулю;\n\nПерейти, если значения равны;\nПерейти, если значения не равны;\n\nПерейти, если значение положительное;\n\nПерейти, если значение отрицательное;\n\nПереходы с учетом знака;\n\nПерейти, если больше (без учета знака), то есть, если операнды не равны и при сравнении не требуется заема;\n\nПерейти, если значение не больше (без учета знака), то есть, если сравниваемые операнды равны или при их сравнении требуется заем;\n\nПерейти, если значение меньше (без учета знака), то есть, если сравнение без знака требует заема;\n\nПерейти, если значение не меньше (без учета знака), то есть, если сравнение без знака не требует заема.\n\nКоманды пропуска\n\nКоманда пропуска может быть выполнена с помощью команды перехода с соответствующем адресом назначения.\n\nЭтот адрес назначения должен указывать на команду, следующую после той, которая стоит непосредственно за командой перехода.\n\nДействительное число пропускаемых байтов будет меняться, так как команды могут иметь длину 1 3 байта.\n\nКоманды вызова подпрограмм и возврата из подпрограмм\n\nКоманда безусловного вызова\n\nКосвенный вызов может быть выполнен с помощью обращения к промежуточной подпрограмме, которая переходит косвенно на вызыва емую подпрограмму.\n\nКоманда условного вызова\n\nУсловный вызов подпрограммы может быть выполнен с помощью последовательностей команд для условного перехода.\n\nЕдинственное отличие состоит в том, что команды перехода к дей ствительным адресам назначения должны быть заменены на команды вызова подпрограмм.\n\nКоманды возврата из подпрограмм разделяются на:\n\nКоманды безусловного возврата\n\nКоманды условного возврата\n\nКоманды возврата с пропуском\n\nКоманды возврата после прерывания\n\nСмешанные команды\n\nВэту категорию входят следующие команды:\n\nнет операции\n\nзапись в стек\n\nполучение из стека\n\nостанов\n\nожидание\n\nзахват (программное прерывание)\n\nдругие, не попавшие в описание ранее категории команд."
		}
	]
}